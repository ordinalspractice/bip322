import * as v from 'valibot';

interface GetCapabilitiesPayload extends RequestPayload {
}
type GetCapabilitiesResponse = Capability[];
type GetCapabilitiesOptions = RequestOptions<GetCapabilitiesPayload, GetCapabilitiesResponse>;

declare const getCapabilities: (options: GetCapabilitiesOptions) => Promise<void>;

interface CreateInscriptionPayload extends RequestPayload {
    contentType: string;
    content: string;
    payloadType: 'PLAIN_TEXT' | 'BASE_64';
    appFee?: number;
    appFeeAddress?: string;
    suggestedMinerFeeRate?: number;
    token?: string;
}
interface CreateRepeatInscriptionsPayload extends CreateInscriptionPayload {
    repeat: number;
}
type CreateInscriptionResponse = {
    txId: string;
};
type CreateRepeatInscriptionsResponse = {
    txId: string;
};
type CreateInscriptionOptions = RequestOptions<CreateInscriptionPayload, CreateInscriptionResponse>;
type CreateRepeatInscriptionsOptions = RequestOptions<CreateRepeatInscriptionsPayload, CreateRepeatInscriptionsResponse>;

declare const createInscription: (options: CreateInscriptionOptions) => Promise<void>;

declare const createRepeatInscriptions: (options: CreateRepeatInscriptionsOptions) => Promise<void>;

interface SignMessagePayload extends RequestPayload {
    address: string;
    message: string;
    protocol?: MessageSigningProtocols;
}
type SignMessageResponse = string;
type SignMessageOptions = RequestOptions<SignMessagePayload, SignMessageResponse>;

declare const signMessage: (options: SignMessageOptions) => Promise<void>;

interface Recipient$2 {
    address: string;
    amountSats: bigint;
}
type SerializedRecipient = Omit<Recipient$2, 'amountSats'> & {
    amountSats: string;
};
interface SendBtcTransactionPayload extends RequestPayload {
    recipients: Recipient$2[];
    senderAddress: string;
    message?: string;
}
type SerializedSendBtcTransactionPayload = Omit<SendBtcTransactionPayload, 'recipients'> & {
    recipients: SerializedRecipient[];
};
type SendBtcTransactionResponse = string;
type SendBtcTransactionOptions = RequestOptions<SendBtcTransactionPayload, SendBtcTransactionResponse>;
interface InputToSign {
    address: string;
    signingIndexes: number[];
    sigHash?: number;
}
type PsbtPayload = {
    psbtBase64: string;
    inputsToSign: InputToSign[];
    broadcast?: boolean;
};
type SignMultiplePsbtPayload = {
    psbtBase64: string;
    inputsToSign: InputToSign[];
};
interface SignTransactionPayload extends RequestPayload, PsbtPayload {
    message: string;
}
interface SignTransactionResponse {
    psbtBase64: string;
    txId?: string;
}
type SignTransactionOptions = RequestOptions<SignTransactionPayload, SignTransactionResponse>;
interface SignMultipleTransactionsPayload extends RequestPayload {
    message: string;
    psbts: SignMultiplePsbtPayload[];
}
type SignMultipleTransactionsResponse = SignTransactionResponse[];
type SignMultipleTransactionOptions = RequestOptions<SignMultipleTransactionsPayload, SignMultipleTransactionsResponse>;

declare const sendBtcTransaction: (options: SendBtcTransactionOptions) => Promise<void>;

declare const signTransaction: (options: SignTransactionOptions) => Promise<void>;

declare const signMultipleTransactions: (options: SignMultipleTransactionOptions) => Promise<void>;

declare const accountChangeEventName = "accountChange";
declare const accountChangeSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"accountChange", undefined>;
}, undefined>;
type AccountChangeEvent = v.InferOutput<typeof accountChangeSchema>;
declare const networkChangeEventName = "networkChange";
declare const networkChangeSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"networkChange", undefined>;
}, undefined>;
type NetworkChangeEvent = v.InferOutput<typeof networkChangeSchema>;
declare const disconnectEventName = "disconnect";
declare const disconnectSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"disconnect", undefined>;
}, undefined>;
type DisconnectEvent = v.InferOutput<typeof disconnectSchema>;
declare const walletEventSchema: v.VariantSchema<"type", [v.ObjectSchema<{
    readonly type: v.LiteralSchema<"accountChange", undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"networkChange", undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"disconnect", undefined>;
}, undefined>], undefined>;
type WalletEvent = v.InferOutput<typeof walletEventSchema>;
type AddListener = <const WalletEventName extends WalletEvent['type']>(eventName: WalletEventName, cb: (event: Extract<WalletEvent, {
    type: WalletEventName;
}>) => void) => () => void;
interface BaseBitcoinProvider {
    request: <Method extends keyof Requests>(method: Method, options: Params<Method>, providerId?: string) => Promise<RpcResponse<Method>>;
    connect: (request: string) => Promise<GetAddressResponse>;
    signMessage: (request: string) => Promise<SignMessageResponse>;
    signTransaction: (request: string) => Promise<SignTransactionResponse>;
    sendBtcTransaction: (request: string) => Promise<SendBtcTransactionResponse>;
    createInscription: (request: string) => Promise<CreateInscriptionResponse>;
    createRepeatInscriptions: (request: string) => Promise<CreateRepeatInscriptionsResponse>;
    signMultipleTransactions: (request: string) => Promise<SignMultipleTransactionsResponse>;
    addListener: AddListener;
}
type Capability = keyof BaseBitcoinProvider;
interface BitcoinProvider extends BaseBitcoinProvider {
    getCapabilities?: (request: string) => Promise<GetCapabilitiesResponse>;
}
interface Provider {
    id: string;
    name: string;
    icon: string;
    webUrl?: string;
    chromeWebStoreUrl?: string;
    mozillaAddOnsUrl?: string;
    googlePlayStoreUrl?: string;
    iOSAppStoreUrl?: string;
    methods?: (StxRequestMethod | BtcRequestMethod | RunesRequestMethod | OrdinalsRequestMethod)[];
}
interface SupportedWallet extends Provider {
    isInstalled: boolean;
}
declare global {
    interface XverseProviders {
        BitcoinProvider?: BitcoinProvider;
    }
    interface Window {
        BitcoinProvider?: BitcoinProvider;
        XverseProviders?: XverseProviders;
        btc_providers?: Provider[];
    }
}

declare function getProviderOrThrow(getProvider?: () => Promise<BitcoinProvider | undefined>): Promise<BitcoinProvider>;
declare function getProviders(): Provider[];
declare function getProviderById(providerId: string): any;
declare function isProviderInstalled(providerId: string): boolean;
declare function setDefaultProvider(providerId: string): void;
declare function getDefaultProvider(): string | null;
declare function removeDefaultProvider(): void;
declare function getSupportedWallets(): SupportedWallet[];

declare enum BitcoinNetworkType {
    Mainnet = "Mainnet",
    Testnet = "Testnet",
    Signet = "Signet"
}
interface BitcoinNetwork {
    type: BitcoinNetworkType;
    address?: string;
}
interface RequestPayload {
    network: BitcoinNetwork;
}
interface RequestOptions<Payload extends RequestPayload, Response> {
    onFinish: (response: Response) => void;
    onCancel: () => void;
    payload: Payload;
    getProvider?: () => Promise<BitcoinProvider | undefined>;
}
declare const RpcIdSchema: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, never>;
type RpcId = v.InferOutput<typeof RpcIdSchema>;
declare const rpcRequestMessageSchema: v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly method: v.StringSchema<undefined>;
    readonly params: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnknownSchema, undefined>, v.LooseObjectSchema<{}, undefined>, v.NullSchema<undefined>], undefined>, never>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, never>;
}, undefined>;
type RpcRequestMessage = v.InferOutput<typeof rpcRequestMessageSchema>;
interface RpcBase {
    jsonrpc: '2.0';
    id: RpcId;
}
interface RpcRequest<T extends string, U> extends RpcBase {
    method: T;
    params: U;
}
interface MethodParamsAndResult<TParams, TResult> {
    params: TParams;
    result: TResult;
}
/**
 * @enum {number} RpcErrorCode
 * @description JSON-RPC error codes
 * @see https://www.jsonrpc.org/specification#error_object
 */
declare enum RpcErrorCode {
    /**
     * Parse error Invalid JSON
     **/
    PARSE_ERROR = -32700,
    /**
     * The JSON sent is not a valid Request object.
     **/
    INVALID_REQUEST = -32600,
    /**
     * The method does not exist/is not available.
     **/
    METHOD_NOT_FOUND = -32601,
    /**
     * Invalid method parameter(s).
     */
    INVALID_PARAMS = -32602,
    /**
     * Internal JSON-RPC error.
     * This is a generic error, used when the server encounters an error in performing the request.
     **/
    INTERNAL_ERROR = -32603,
    /**
     * user rejected/canceled the request
     */
    USER_REJECTION = -32000,
    /**
     * method is not supported for the address provided
     */
    METHOD_NOT_SUPPORTED = -32001,
    /**
     * The client does not have permission to access the requested resource.
     */
    ACCESS_DENIED = -32002
}
declare const rpcSuccessResponseMessageSchema: v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly result: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, never>;
}, undefined>;
type RpcSuccessResponseMessage = v.InferOutput<typeof rpcSuccessResponseMessageSchema>;
declare const rpcErrorResponseMessageSchema: v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly error: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, never>;
}, undefined>;
type RpcErrorResponseMessage = v.InferOutput<typeof rpcErrorResponseMessageSchema>;
declare const rpcResponseMessageSchema: v.UnionSchema<[v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly result: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, never>;
}, undefined>, v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly error: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, never>;
}, undefined>], undefined>;
type RpcResponseMessage = v.InferOutput<typeof rpcResponseMessageSchema>;
interface RpcError {
    code: number | RpcErrorCode;
    message: string;
    data?: any;
}
interface RpcErrorResponse<TError extends RpcError = RpcError> extends RpcBase {
    error: TError;
}
interface RpcSuccessResponse<Method extends keyof Requests> extends RpcBase {
    result: Return<Method>;
}
type RpcResponse<Method extends keyof Requests> = RpcSuccessResponse<Method> | RpcErrorResponse;
type RpcResult<Method extends keyof Requests> = {
    result: RpcSuccessResponse<Method>['result'];
    status: 'success';
} | {
    error: RpcErrorResponse['error'];
    status: 'error';
};

declare enum AddressPurpose {
    Ordinals = "ordinals",
    Payment = "payment",
    Stacks = "stacks"
}
interface GetAddressPayload extends RequestPayload {
    purposes: AddressPurpose[];
    message: string;
}
declare enum AddressType {
    p2pkh = "p2pkh",
    p2sh = "p2sh",
    p2wpkh = "p2wpkh",
    p2wsh = "p2wsh",
    p2tr = "p2tr",
    stacks = "stacks"
}
declare const addressSchema: v.ObjectSchema<{
    readonly address: v.StringSchema<undefined>;
    readonly publicKey: v.StringSchema<undefined>;
    readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
    readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
}, undefined>;
type Address$1 = v.InferOutput<typeof addressSchema>;
interface GetAddressResponse {
    addresses: Address$1[];
}
type GetAddressOptions = RequestOptions<GetAddressPayload, GetAddressResponse>;

/**
 * @deprecated Use `request()` instead
 */
declare const getAddress: (options: GetAddressOptions) => Promise<void>;

declare const getInfoMethodName = "getInfo";
declare const getInfoParamsSchema: v.NullishSchema<v.NullSchema<undefined>, never>;
type GetInfoParams = v.InferOutput<typeof getInfoParamsSchema>;
declare const getInfoResultSchema: v.ObjectSchema<{
    /**
     * Version of the wallet.
     */
    readonly version: v.StringSchema<undefined>;
    /**
     * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
     */
    readonly methods: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, never>;
    /**
     * List of WBIP standards supported by the wallet. Not currently used.
     */
    readonly supports: v.ArraySchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type GetInfoResult = v.InferOutput<typeof getInfoResultSchema>;
declare const getInfoRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getInfo", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, never>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetInfoRequestMessage = v.InferOutput<typeof getInfoRequestMessageSchema>;
type GetInfo = MethodParamsAndResult<v.InferOutput<typeof getInfoParamsSchema>, v.InferOutput<typeof getInfoResultSchema>>;
declare const getAddressesMethodName = "getAddresses";
declare const getAddressesParamsSchema: v.ObjectSchema<{
    /**
     * The purposes for which to generate addresses. See
     * {@linkcode AddressPurpose} for available purposes.
     */
    readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
    /**
     * A message to be displayed to the user in the request prompt.
     */
    readonly message: v.OptionalSchema<v.StringSchema<undefined>, never>;
}, undefined>;
type GetAddressesParams = v.InferOutput<typeof getAddressesParamsSchema>;
declare const getAddressesResultSchema: v.ObjectSchema<{
    /**
     * The addresses generated for the given purposes.
     */
    readonly addresses: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>; /**
         * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
         */
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
    }, undefined>, undefined>;
}, undefined>;
type GetAddressesResult = v.InferOutput<typeof getAddressesResultSchema>;
declare const getAddressesRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getAddresses", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The purposes for which to generate addresses. See
         * {@linkcode AddressPurpose} for available purposes.
         */
        readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
        /**
         * A message to be displayed to the user in the request prompt.
         */
        readonly message: v.OptionalSchema<v.StringSchema<undefined>, never>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetAddressesRequestMessage = v.InferOutput<typeof getAddressesRequestMessageSchema>;
type GetAddresses = MethodParamsAndResult<v.InferOutput<typeof getAddressesParamsSchema>, v.InferOutput<typeof getAddressesResultSchema>>;
declare const signMessageMethodName = "signMessage";
declare enum MessageSigningProtocols {
    ECDSA = "ECDSA",
    BIP322 = "BIP322"
}
declare const signMessageParamsSchema: v.ObjectSchema<{
    /**
     * The address used for signing.
     **/
    readonly address: v.StringSchema<undefined>;
    /**
     * The message to sign.
     **/
    readonly message: v.StringSchema<undefined>;
    /**
     * The protocol to use for signing the message.
     */
    readonly protocol: v.OptionalSchema<v.EnumSchema<typeof MessageSigningProtocols, undefined>, never>;
}, undefined>;
type SignMessageParams = v.InferOutput<typeof signMessageParamsSchema>;
declare const signMessageResultSchema: v.ObjectSchema<{
    /**
     * The signature of the message.
     */
    readonly signature: v.StringSchema<undefined>;
    /**
     * hash of the message.
     */
    readonly messageHash: v.StringSchema<undefined>;
    /**
     * The address used for signing.
     */
    readonly address: v.StringSchema<undefined>;
    /**
     * The protocol to use for signing the message.
     */
    readonly protocol: v.EnumSchema<typeof MessageSigningProtocols, undefined>;
}, undefined>;
type SignMessageResult = v.InferOutput<typeof signMessageResultSchema>;
declare const signMessageRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"signMessage", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The address used for signing.
         **/
        readonly address: v.StringSchema<undefined>;
        /**
         * The message to sign.
         **/
        readonly message: v.StringSchema<undefined>;
        /**
         * The protocol to use for signing the message.
         */
        readonly protocol: v.OptionalSchema<v.EnumSchema<typeof MessageSigningProtocols, undefined>, never>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type SignMessageRequestMessage = v.InferOutput<typeof signMessageRequestMessageSchema>;
type SignMessage = MethodParamsAndResult<v.InferOutput<typeof signMessageParamsSchema>, v.InferOutput<typeof signMessageResultSchema>>;
type Recipient$1 = {
    /**
     * The recipient's address.
     **/
    address: string;
    /**
     * The amount to send to the recipient in satoshis.
     */
    amount: number;
};
type SendTransferParams = {
    /**
     * Array of recipients to send to.
     * The amount to send to each recipient is in satoshis.
     */
    recipients: Array<Recipient$1>;
};
type SendTransferResult = {
    /**
     * The transaction id as a hex-encoded string.
     */
    txid: string;
};
type SendTransfer = MethodParamsAndResult<SendTransferParams, SendTransferResult>;
type SignPsbtParams = {
    /**
     * The base64 encoded PSBT to sign.
     */
    psbt: string;
    /**
     * The inputs to sign.
     * The key is the address and the value is an array of indexes of the inputs to sign.
     */
    signInputs: Record<string, number[]>;
    /**
     * Whether to broadcast the transaction after signing.
     **/
    broadcast?: boolean;
};
type SignPsbtResult = {
    /**
     * The base64 encoded PSBT after signing.
     */
    psbt: string;
    /**
     * The transaction id as a hex-encoded string.
     * This is only returned if the transaction was broadcast.
     **/
    txid?: string;
};
type SignPsbt = MethodParamsAndResult<SignPsbtParams, SignPsbtResult>;
declare const getAccountsMethodName = "getAccounts";
declare const getAccountsParamsSchema: v.ObjectSchema<{
    /**
     * The purposes for which to generate addresses. See
     * {@linkcode AddressPurpose} for available purposes.
     */
    readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
    /**
     * A message to be displayed to the user in the request prompt.
     */
    readonly message: v.OptionalSchema<v.StringSchema<undefined>, never>;
}, undefined>;
type GetAccountsParams = v.InferOutput<typeof getAccountsParamsSchema>;
declare const getAccountsResultSchema: v.ArraySchema<v.ObjectSchema<{
    readonly walletType: v.PicklistSchema<readonly ["software", "ledger"], undefined>;
    readonly address: v.StringSchema<undefined>;
    readonly publicKey: v.StringSchema<undefined>;
    readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>; /**
     * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
     */
    readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
}, undefined>, undefined>;
type GetAccountsResult = v.InferOutput<typeof getAccountsResultSchema>;
declare const getAccountsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getAccounts", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The purposes for which to generate addresses. See
         * {@linkcode AddressPurpose} for available purposes.
         */
        readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
        /**
         * A message to be displayed to the user in the request prompt.
         */
        readonly message: v.OptionalSchema<v.StringSchema<undefined>, never>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetAccountsRequestMessage = v.InferOutput<typeof getAccountsRequestMessageSchema>;
type GetAccounts = MethodParamsAndResult<v.InferOutput<typeof getAccountsParamsSchema>, v.InferOutput<typeof getAccountsResultSchema>>;
declare const getBalanceMethodName = "getBalance";
declare const getBalanceParamsSchema: v.NullishSchema<v.NullSchema<undefined>, never>;
declare const getBalanceResultSchema: v.ObjectSchema<{
    /**
     * The confirmed balance of the wallet in sats. Using a string due to chrome
     * messages not supporting bigint
     * (https://issues.chromium.org/issues/40116184).
     */
    readonly confirmed: v.StringSchema<undefined>;
    /**
     * The unconfirmed balance of the wallet in sats. Using a string due to chrome
     * messages not supporting bigint
     * (https://issues.chromium.org/issues/40116184).
     */
    readonly unconfirmed: v.StringSchema<undefined>;
    /**
     * The total balance (both confirmed and unconfrimed UTXOs) of the wallet in
     * sats. Using a string due to chrome messages not supporting bigint
     * (https://issues.chromium.org/issues/40116184).
     */
    readonly total: v.StringSchema<undefined>;
}, undefined>;
declare const getBalanceRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getBalance", undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly params: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnknownSchema, undefined>, v.LooseObjectSchema<{}, undefined>, v.NullSchema<undefined>], undefined>, never>;
}, undefined>;
type GetBalance = MethodParamsAndResult<v.InferOutput<typeof getBalanceParamsSchema>, v.InferOutput<typeof getBalanceResultSchema>>;

declare const getInscriptionsMethodName = "ord_getInscriptions";
declare const getInscriptionsParamsSchema: v.ObjectSchema<{
    readonly offset: v.NumberSchema<undefined>;
    readonly limit: v.NumberSchema<undefined>;
}, undefined>;
declare const getInscriptionsResultSchema: v.ObjectSchema<{
    readonly total: v.NumberSchema<undefined>;
    readonly limit: v.NumberSchema<undefined>;
    readonly offset: v.NumberSchema<undefined>;
    readonly inscriptions: v.ArraySchema<v.ObjectSchema<{
        readonly inscriptionId: v.StringSchema<undefined>;
        readonly inscriptionNumber: v.StringSchema<undefined>;
        readonly address: v.StringSchema<undefined>;
        readonly collectionName: v.OptionalSchema<v.StringSchema<undefined>, never>;
        readonly postage: v.StringSchema<undefined>;
        readonly contentLength: v.StringSchema<undefined>;
        readonly contentType: v.StringSchema<undefined>;
        readonly timestamp: v.NumberSchema<undefined>;
        readonly offset: v.NumberSchema<undefined>;
        readonly genesisTransaction: v.StringSchema<undefined>;
        readonly output: v.StringSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
declare const getInscriptionsSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"ord_getInscriptions", undefined>;
    readonly params: v.ObjectSchema<{
        readonly offset: v.NumberSchema<undefined>;
        readonly limit: v.NumberSchema<undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetInscriptions = MethodParamsAndResult<v.InferOutput<typeof getInscriptionsParamsSchema>, v.InferOutput<typeof getInscriptionsResultSchema>>;
declare const sendInscriptionsMethodName = "ord_sendInscriptions";
declare const sendInscriptionsParamsSchema: v.ObjectSchema<{
    readonly transfers: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly inscriptionId: v.StringSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
declare const sendInscriptionsResultSchema: v.ObjectSchema<{
    readonly txid: v.StringSchema<undefined>;
}, undefined>;
declare const sendInscriptionsSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"ord_sendInscriptions", undefined>;
    readonly params: v.ObjectSchema<{
        readonly transfers: v.ArraySchema<v.ObjectSchema<{
            readonly address: v.StringSchema<undefined>;
            readonly inscriptionId: v.StringSchema<undefined>;
        }, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type SendInscriptions = MethodParamsAndResult<v.InferOutput<typeof sendInscriptionsParamsSchema>, v.InferOutput<typeof sendInscriptionsResultSchema>>;

type CreateMintOrderRequest = {
    runeName: string;
    repeats: number;
    refundAddress: string;
    destinationAddress: string;
    feeRate: number;
    appServiceFee?: number;
    appServiceFeeAddress?: string;
};
type EstimateMintOrderRequest = Omit<CreateMintOrderRequest, 'refundAddress'>;
type EstimateOrderResponse = {
    totalSize: number;
    totalCost: number;
    costBreakdown: {
        postage: number;
        networkFee: number;
        serviceFee: number;
        appServiceFee: number;
    };
};
type CreateEtchOrderRequest = {
    runeName: string;
    divisibility?: number;
    symbol?: string;
    premine?: string;
    isMintable: boolean;
    terms?: {
        amount?: string;
        cap?: string;
        heightStart?: string;
        heightEnd?: string;
        offsetStart?: string;
        offsetEnd?: string;
    };
    inscriptionDetails?: {
        contentType: string;
        contentBase64: string;
    };
    delegateInscriptionId?: string;
    destinationAddress: string;
    refundAddress: string;
    feeRate: number;
    appServiceFee?: number;
    appServiceFeeAddress?: string;
};
type EstimateEtchOrderRequest = Omit<CreateEtchOrderRequest, 'refundAddress'>;
type GetOrderRequest = {
    id: string;
};
type GetOrderResponse = {
    id: string;
    orderType: 'rune_mint' | 'rune_etch';
    state: 'new' | 'pending' | 'executing' | 'complete' | 'failed' | 'refunded' | 'stale';
    fundingAddress: string;
    reason?: string;
    createdAt: string;
};
type RBFOrderRequest = {
    orderId: string;
    newFeeRate: number;
};
type RBFOrderResponse = {
    rbfCost: number;
    fundingAddress: string;
};

interface EstimateRunesMintParams extends EstimateMintOrderRequest {
    network?: BitcoinNetworkType;
}
type EstimateRunesMintResult = EstimateOrderResponse;
type EstimateRunesMint = MethodParamsAndResult<EstimateRunesMintParams, EstimateRunesMintResult>;
interface MintRunesParams extends CreateMintOrderRequest {
    network?: BitcoinNetworkType;
}
type MintRunesResult = {
    orderId: string;
    fundTransactionId: string;
    fundingAddress: string;
};
type MintRunes = MethodParamsAndResult<MintRunesParams, MintRunesResult>;
interface EstimateRunesEtchParams extends EstimateEtchOrderRequest {
    network?: BitcoinNetworkType;
}
type EstimateRunesEtchResult = EstimateOrderResponse;
type EstimateRunesEtch = MethodParamsAndResult<EstimateRunesEtchParams, EstimateRunesEtchResult>;
interface EtchRunesParams extends CreateEtchOrderRequest {
    network?: BitcoinNetworkType;
}
type EtchRunesResult = {
    orderId: string;
    fundTransactionId: string;
    fundingAddress: string;
};
type EtchRunes = MethodParamsAndResult<EtchRunesParams, EtchRunesResult>;
interface GetOrderParams extends GetOrderRequest {
    network?: BitcoinNetworkType;
}
type GetOrder = MethodParamsAndResult<GetOrderParams, GetOrderResponse>;
interface EstimateRbfOrderParams extends RBFOrderRequest {
    network?: BitcoinNetworkType;
}
type EstimateRbfOrder = MethodParamsAndResult<EstimateRbfOrderParams, RBFOrderResponse>;
interface RbfOrderParams extends RBFOrderRequest {
    network?: BitcoinNetworkType;
}
interface RbfOrderResult {
    orderId: string;
    fundRBFTransactionId: string;
    fundingAddress: string;
}
type RbfOrder = MethodParamsAndResult<RbfOrderParams, RbfOrderResult>;
declare const getRunesBalanceMethodName = "runes_getBalance";
declare const getRunesBalanceParamsSchema: v.NullishSchema<v.NullSchema<undefined>, never>;
type GetRunesBalanceParams = v.InferOutput<typeof getRunesBalanceParamsSchema>;
declare const getRunesBalanceResultSchema: v.ObjectSchema<{
    readonly balances: v.ArraySchema<v.ObjectSchema<{
        readonly runeName: v.StringSchema<undefined>;
        readonly amount: v.StringSchema<undefined>;
        readonly divisibility: v.NumberSchema<undefined>;
        readonly symbol: v.StringSchema<undefined>;
        readonly inscriptionId: v.NullishSchema<v.StringSchema<undefined>, never>;
    }, undefined>, undefined>;
}, undefined>;
type GetRunesBalanceResult = v.InferOutput<typeof getRunesBalanceResultSchema>;
declare const getRunesBalanceRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"runes_getBalance", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, never>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetRunesBalanceRequestMessage = v.InferOutput<typeof getRunesBalanceRequestMessageSchema>;
type GetRunesBalance = MethodParamsAndResult<v.InferOutput<typeof getRunesBalanceParamsSchema>, v.InferOutput<typeof getRunesBalanceResultSchema>>;
declare const transferRunesMethodName = "runes_transfer";
declare const transferRunesParamsSchema: v.ObjectSchema<{
    readonly recipients: v.ArraySchema<v.ObjectSchema<{
        readonly runeName: v.StringSchema<undefined>;
        readonly amount: v.StringSchema<undefined>;
        readonly address: v.StringSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
type TransferRunesParams = v.InferOutput<typeof transferRunesParamsSchema>;
declare const transferRunesRequestSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"runes_transfer", undefined>;
    readonly params: v.ObjectSchema<{
        readonly recipients: v.ArraySchema<v.ObjectSchema<{
            readonly runeName: v.StringSchema<undefined>;
            readonly amount: v.StringSchema<undefined>;
            readonly address: v.StringSchema<undefined>;
        }, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type TransferRunesRequest = v.InferOutput<typeof transferRunesRequestSchema>;
declare const TransferRunesResultSchema: v.ObjectSchema<{
    readonly txid: v.StringSchema<undefined>;
}, undefined>;
type TransferRunesResult = v.InferOutput<typeof TransferRunesResultSchema>;
type TransferRunes = MethodParamsAndResult<TransferRunesParams, TransferRunesResult>;

interface Pubkey {
    /**
     * When sending a transfer STX request to a wallet, users can generally
     * choose from which accout they want to send the STX tokens from. In
     * cases where applications want the transfer to be made from a specific
     * account, they can provide the `pubkey` of the address they'd like the
     * transfer to be made from. It is up to wallet providers to handle this
     * field as they see fit.
     */
    pubkey: string;
}
interface Address {
    /**
     * A Crockford base-32 encoded Stacks address.
     */
    address: string;
}
interface PostConditions {
    /**
     * A hex-encoded string representing the post conditions.
     *
     * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
     *
     * ```js
     * import { serializePostCondition } from '@stacks/transactions';
     *
     * const postCondition = somePostCondition;
     * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
     * ```
     */
    postConditions: Array<string>;
}
interface PostConditionMode {
    /**
     * The mode of the post conditions.
     */
    postConditionMode: number;
}
interface ParameterFormatVersion {
    /**
     * Version of parameter format.
     */
    version: string;
}
interface Recipient {
    /**
     * The recipeint's Crockford base-32 encoded Stacks address.
     */
    recipient: string;
}
interface Amount {
    /**
     * Amount of STX tokens to transfer in microstacks as a string. Anything
     * parseable by `BigInt` is acceptable.
     *
     * Example,
     *
     * ```js
     * const amount1 = 1234;
     * const amount2 = 1234n;
     * const amount3 = '1234';
     * ```
     */
    amount: number | string;
}
interface Memo {
    /**
     * A string representing the memo.
     */
    memo: string;
}
interface TxId {
    /**
     * The ID of the transaction.
     */
    txid: string;
}
interface Transaction {
    /**
     * A Stacks transaction as a hex-encoded string.
     */
    transaction: string;
}
interface Message {
    /**
     * Message payload to be signed.
     */
    message: string;
}
interface Signature {
    /**
     * Signature of the message.
     */
    signature: string;
}
interface PublicKey {
    /**
     * Public key as hex-encoded string.
     */
    publicKey: string;
}
interface Domain {
    /**
     * The domain to be signed.
     */
    domain: string;
}
interface CallContractParams {
    /**
     * The contract's Crockford base-32 encoded Stacks address and name.
     *
     * E.g. `"SPKE...GD5C.my-contract"`
     */
    contract: string;
    /**
     * The name of the function to call.
     *
     * Note: spec changes ongoing,
     * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
     */
    functionName: string;
    /**
     * The function's arguments. The arguments are expected to be hex-encoded
     * strings of Clarity values.
     *
     * To convert Clarity values to their hex representation, the `cvToString`
     * helper from the `@stacks/transactions` package may be helpful.
     *
     * ```js
     * import { cvToString } from '@stacks/transactions';
     *
     * const functionArgs = [someClarityValue1, someClarityValue2];
     * const hexArgs = functionArgs.map(cvToString);
     * ```
     */
    arguments?: Array<string>;
}
type CallContractResult = TxId & Transaction;
type StxCallContract = MethodParamsAndResult<CallContractParams, CallContractResult>;
type TransferStxParams = Amount & Recipient & Partial<Memo> & Partial<ParameterFormatVersion> & Partial<PostConditionMode> & Partial<PostConditions> & Partial<Pubkey>;
type TransferStxResult = TxId & Transaction;
type StxTransferStx = MethodParamsAndResult<TransferStxParams, TransferStxResult>;
type SignStxMessageParams = Message & Partial<Pubkey> & Partial<ParameterFormatVersion>;
type SignStxMessageResult = Signature & PublicKey;
type StxSignStxMessage = MethodParamsAndResult<SignStxMessageParams, SignStxMessageResult>;
type SignStructuredMessageParams = Domain & Message & Partial<ParameterFormatVersion> & Partial<Pubkey>;
type SignStructuredMessageResult = Signature & PublicKey;
type StxSignStructuredMessage = MethodParamsAndResult<SignStructuredMessageParams, SignStructuredMessageResult>;
interface DeployContractParams {
    /**
     * Name of the contract.
     */
    name: string;
    /**
     * The code of the Clarity contract.
     */
    clarityCode: string;
    /**
     * The version of the Clarity contract.
     */
    clarityVersion?: string;
}
type DeployContractResult = TxId & Transaction;
type StxDeployContract = MethodParamsAndResult<DeployContractParams, DeployContractResult>;
type StxGetAccountsResult = {
    addresses: Array<Address & PublicKey & {
        gaiaHubUrl: string;
        gaiaAppKey: string;
    }>;
};
type StxGetAccounts = MethodParamsAndResult<{}, StxGetAccountsResult>;
declare const stxGetAddressesMethodName = "stx_getAddresses";
declare const stxGetAddressesParamsSchema: v.NullishSchema<v.ObjectSchema<{
    /**
     * A message to be displayed to the user in the request prompt.
     */
    readonly message: v.OptionalSchema<v.StringSchema<undefined>, never>;
}, undefined>, never>;
type StxGetAddressesParams = v.InferOutput<typeof stxGetAddressesParamsSchema>;
declare const stxGetAddressesResultSchema: v.ObjectSchema<{
    /**
     * The addresses generated for the given purposes.
     */
    readonly addresses: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
    }, undefined>, undefined>;
}, undefined>;
type StxGetAddressesResult = v.InferOutput<typeof stxGetAddressesResultSchema>;
declare const stxGetAddressesRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_getAddresses", undefined>;
    readonly params: v.NullishSchema<v.ObjectSchema<{
        /**
         * A message to be displayed to the user in the request prompt.
         */
        readonly message: v.OptionalSchema<v.StringSchema<undefined>, never>;
    }, undefined>, never>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxGetAddressesRequestMessage = v.InferOutput<typeof stxGetAddressesRequestMessageSchema>;
type StxGetAddresses = MethodParamsAndResult<v.InferOutput<typeof stxGetAddressesParamsSchema>, v.InferOutput<typeof stxGetAddressesResultSchema>>;
declare const stxSignTransactionMethodName = "stx_signTransaction";
declare const stxSignTransactionParamsSchema: v.ObjectSchema<{
    /**
     * The transaction to sign as a hex-encoded string.
     */
    readonly transaction: v.StringSchema<undefined>;
    /**
     * The public key to sign the transaction with. The wallet may use any key
     * when not provided.
     */
    readonly pubkey: v.OptionalSchema<v.StringSchema<undefined>, never>;
    /**
     * Whether to broadcast the transaction after signing. Defaults to `true`.
     */
    readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, never>;
}, undefined>;
type StxSignTransactionParams = v.InferOutput<typeof stxSignTransactionParamsSchema>;
declare const stxSignTransactionResultSchema: v.ObjectSchema<{
    /**
     * The signed transaction as a hex-encoded string.
     */
    readonly transaction: v.StringSchema<undefined>;
}, undefined>;
type StxSignTransactionResult = v.InferOutput<typeof stxSignTransactionResultSchema>;
declare const stxSignTransactionRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_signTransaction", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The transaction to sign as a hex-encoded string.
         */
        readonly transaction: v.StringSchema<undefined>;
        /**
         * The public key to sign the transaction with. The wallet may use any key
         * when not provided.
         */
        readonly pubkey: v.OptionalSchema<v.StringSchema<undefined>, never>;
        /**
         * Whether to broadcast the transaction after signing. Defaults to `true`.
         */
        readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, never>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxSignTransactionRequestMessage = v.InferOutput<typeof stxSignTransactionRequestMessageSchema>;
type StxSignTransaction = MethodParamsAndResult<StxSignTransactionParams, StxSignTransactionResult>;

declare const requestPermissionsMethodName = "wallet_requestPermissions";
declare const requestPermissionsParamsSchema: v.UndefinedSchema<undefined>;
declare const requestPermissionsResultSchema: v.LiteralSchema<true, undefined>;
declare const requestPermissionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_requestPermissions", undefined>;
    readonly params: v.UndefinedSchema<undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type RequestPermissions = MethodParamsAndResult<v.InferOutput<typeof requestPermissionsParamsSchema>, v.InferOutput<typeof requestPermissionsResultSchema>>;
declare const renouncePermissionsMethodName = "wallet_renouncePermissions";
declare const renouncePermissionsParamsSchema: v.UndefinedSchema<undefined>;
declare const renouncePermissionsResultSchema: v.LiteralSchema<true, undefined>;
declare const renouncePermissionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_renouncePermissions", undefined>;
    readonly params: v.UndefinedSchema<undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type RenouncePermissions = MethodParamsAndResult<v.InferOutput<typeof renouncePermissionsParamsSchema>, v.InferOutput<typeof renouncePermissionsResultSchema>>;
declare const getWalletTypeMethodName = "wallet_getWalletType";
declare const getWalletTypeParamsSchema: v.NullishSchema<v.NullSchema<undefined>, never>;
declare const getWalletTypeResultSchema: v.PicklistSchema<readonly ["software", "ledger"], undefined>;
declare const getWalletTypeRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_getWalletType", undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly params: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnknownSchema, undefined>, v.LooseObjectSchema<{}, undefined>, v.NullSchema<undefined>], undefined>, never>;
}, undefined>;
type GetWalletType = MethodParamsAndResult<v.InferOutput<typeof getWalletTypeParamsSchema>, v.InferOutput<typeof getWalletTypeResultSchema>>;

declare const walletTypes: readonly ["software", "ledger"];
declare const walletTypeSchema: v.PicklistSchema<readonly ["software", "ledger"], undefined>;
type WalletType = v.InferOutput<typeof walletTypeSchema>;

interface StxRequests {
    stx_callContract: StxCallContract;
    stx_deployContract: StxDeployContract;
    stx_getAccounts: StxGetAccounts;
    stx_getAddresses: StxGetAddresses;
    stx_signMessage: StxSignStxMessage;
    stx_signStructuredMessage: StxSignStructuredMessage;
    stx_signTransaction: StxSignTransaction;
    stx_transferStx: StxTransferStx;
}
type StxRequestMethod = keyof StxRequests;
interface BtcRequests {
    getInfo: GetInfo;
    getAddresses: GetAddresses;
    getAccounts: GetAccounts;
    getBalance: GetBalance;
    signMessage: SignMessage;
    sendTransfer: SendTransfer;
    signPsbt: SignPsbt;
}
type BtcRequestMethod = keyof BtcRequests;
interface RunesRequests {
    runes_estimateMint: EstimateRunesMint;
    runes_mint: MintRunes;
    runes_estimateEtch: EstimateRunesEtch;
    runes_etch: EtchRunes;
    runes_getOrder: GetOrder;
    runes_estimateRbfOrder: EstimateRbfOrder;
    runes_rbfOrder: RbfOrder;
    runes_getBalance: GetRunesBalance;
    runes_transfer: TransferRunes;
}
type RunesRequestMethod = keyof RunesRequests;
interface OrdinalsRequests {
    ord_getInscriptions: GetInscriptions;
    ord_sendInscriptions: SendInscriptions;
}
type OrdinalsRequestMethod = keyof OrdinalsRequests;
interface WalletRequests {
    wallet_requestPermissions: RequestPermissions;
    wallet_renouncePermissions: RenouncePermissions;
    wallet_getWalletType: GetWalletType;
}
type Requests = BtcRequests & StxRequests & RunesRequests & WalletRequests & OrdinalsRequests;
type Return<Method> = Method extends keyof Requests ? Requests[Method]['result'] : never;
type Params<Method> = Method extends keyof Requests ? Requests[Method]['params'] : never;

declare const request: <Method extends keyof BtcRequests | keyof StxRequests | keyof RunesRequests | keyof WalletRequests | keyof OrdinalsRequests>(method: Method, params: Params<Method>, providerId?: string) => Promise<RpcResult<Method>>;
declare const addListener: (event: Parameters<AddListener>[0], cb: Parameters<AddListener>[1], providerId?: string) => ReturnType<AddListener>;

declare abstract class SatsConnectAdapter {
    abstract readonly id: string;
    private mintRunes;
    private etchRunes;
    private estimateMint;
    private estimateEtch;
    private getOrder;
    private estimateRbfOrder;
    private rbfOrder;
    request<Method extends keyof Requests>(method: Method, params: Params<Method>): Promise<RpcResult<Method>>;
    abstract addListener: AddListener;
    protected abstract requestInternal<Method extends keyof Requests>(method: Method, params: Params<Method>): Promise<RpcResult<Method>>;
}

declare class BaseAdapter extends SatsConnectAdapter {
    id: string;
    constructor(providerId: string);
    requestInternal: <Method extends keyof BtcRequests | keyof StxRequests | keyof RunesRequests | keyof WalletRequests | keyof OrdinalsRequests>(method: Method, params: Params<Method>) => Promise<RpcResult<Method>>;
    addListener: AddListener;
}

declare const DefaultAdaptersInfo: Record<string, Provider>;
declare const defaultAdapters: Record<string, new () => SatsConnectAdapter>;

export { type AccountChangeEvent, type AddListener, type Address$1 as Address, AddressPurpose, AddressType, BaseAdapter, type BitcoinNetwork, BitcoinNetworkType, type BitcoinProvider, type BtcRequestMethod, type BtcRequests, type CallContractParams, type CallContractResult, type Capability, type CreateInscriptionOptions, type CreateInscriptionPayload, type CreateInscriptionResponse, type CreateRepeatInscriptionsOptions, type CreateRepeatInscriptionsPayload, type CreateRepeatInscriptionsResponse, DefaultAdaptersInfo, type DeployContractParams, type DeployContractResult, type DisconnectEvent, type EstimateRbfOrder, type EstimateRunesEtch, type EstimateRunesEtchParams, type EstimateRunesEtchResult, type EstimateRunesMint, type EstimateRunesMintParams, type EstimateRunesMintResult, type EtchRunes, type EtchRunesParams, type EtchRunesResult, type GetAccounts, type GetAccountsParams, type GetAccountsRequestMessage, type GetAccountsResult, type GetAddressOptions, type GetAddressPayload, type GetAddressResponse, type GetAddresses, type GetAddressesParams, type GetAddressesRequestMessage, type GetAddressesResult, type GetBalance, type GetCapabilitiesOptions, type GetCapabilitiesPayload, type GetCapabilitiesResponse, type GetInfo, type GetInfoParams, type GetInfoRequestMessage, type GetInfoResult, type GetInscriptions, type GetOrder, type GetRunesBalance, type GetRunesBalanceParams, type GetRunesBalanceRequestMessage, type GetRunesBalanceResult, type GetWalletType, type InputToSign, MessageSigningProtocols, type MethodParamsAndResult, type MintRunes, type MintRunesParams, type MintRunesResult, type NetworkChangeEvent, type OrdinalsRequestMethod, type OrdinalsRequests, type Params, type Provider, type PsbtPayload, type RbfOrder, type Recipient$2 as Recipient, type RenouncePermissions, type RequestOptions, type RequestPayload, type RequestPermissions, type Requests, type Return, type RpcBase, type RpcError, RpcErrorCode, type RpcErrorResponse, type RpcErrorResponseMessage, type RpcId, RpcIdSchema, type RpcRequest, type RpcRequestMessage, type RpcResponse, type RpcResponseMessage, type RpcResult, type RpcSuccessResponse, type RpcSuccessResponseMessage, type RunesRequestMethod, type RunesRequests, SatsConnectAdapter, type SendBtcTransactionOptions, type SendBtcTransactionPayload, type SendBtcTransactionResponse, type SendInscriptions, type SendTransfer, type SendTransferParams, type SerializedRecipient, type SerializedSendBtcTransactionPayload, type SignMessage, type SignMessageOptions, type SignMessageParams, type SignMessagePayload, type SignMessageRequestMessage, type SignMessageResponse, type SignMessageResult, type SignMultiplePsbtPayload, type SignMultipleTransactionOptions, type SignMultipleTransactionsPayload, type SignMultipleTransactionsResponse, type SignPsbt, type SignPsbtParams, type SignPsbtResult, type SignStructuredMessageResult, type SignStxMessageParams, type SignStxMessageResult, type SignTransactionOptions, type SignTransactionPayload, type SignTransactionResponse, type StxCallContract, type StxDeployContract, type StxGetAccounts, type StxGetAccountsResult, type StxGetAddresses, type StxGetAddressesParams, type StxGetAddressesRequestMessage, type StxGetAddressesResult, type StxRequestMethod, type StxRequests, type StxSignStructuredMessage, type StxSignStxMessage, type StxSignTransaction, type StxSignTransactionParams, type StxSignTransactionRequestMessage, type StxSignTransactionResult, type StxTransferStx, type SupportedWallet, type TransferRunes, type TransferRunesParams, type TransferRunesRequest, type TransferRunesResult, TransferRunesResultSchema, type TransferStxParams, type TransferStxResult, type WalletEvent, type WalletRequests, type WalletType, accountChangeEventName, accountChangeSchema, addListener, addressSchema, createInscription, createRepeatInscriptions, defaultAdapters, disconnectEventName, disconnectSchema, getAccountsMethodName, getAccountsParamsSchema, getAccountsRequestMessageSchema, getAccountsResultSchema, getAddress, getAddressesMethodName, getAddressesParamsSchema, getAddressesRequestMessageSchema, getAddressesResultSchema, getBalanceMethodName, getBalanceParamsSchema, getBalanceRequestMessageSchema, getBalanceResultSchema, getCapabilities, getDefaultProvider, getInfoMethodName, getInfoParamsSchema, getInfoRequestMessageSchema, getInfoResultSchema, getInscriptionsMethodName, getInscriptionsParamsSchema, getInscriptionsResultSchema, getInscriptionsSchema, getProviderById, getProviderOrThrow, getProviders, getRunesBalanceMethodName, getRunesBalanceParamsSchema, getRunesBalanceRequestMessageSchema, getRunesBalanceResultSchema, getSupportedWallets, getWalletTypeMethodName, getWalletTypeParamsSchema, getWalletTypeRequestMessageSchema, getWalletTypeResultSchema, isProviderInstalled, networkChangeEventName, networkChangeSchema, removeDefaultProvider, renouncePermissionsMethodName, renouncePermissionsParamsSchema, renouncePermissionsRequestMessageSchema, renouncePermissionsResultSchema, request, requestPermissionsMethodName, requestPermissionsParamsSchema, requestPermissionsRequestMessageSchema, requestPermissionsResultSchema, rpcErrorResponseMessageSchema, rpcRequestMessageSchema, rpcResponseMessageSchema, rpcSuccessResponseMessageSchema, sendBtcTransaction, sendInscriptionsMethodName, sendInscriptionsParamsSchema, sendInscriptionsResultSchema, sendInscriptionsSchema, setDefaultProvider, signMessage, signMessageMethodName, signMessageParamsSchema, signMessageRequestMessageSchema, signMessageResultSchema, signMultipleTransactions, signTransaction, stxGetAddressesMethodName, stxGetAddressesParamsSchema, stxGetAddressesRequestMessageSchema, stxGetAddressesResultSchema, stxSignTransactionMethodName, stxSignTransactionParamsSchema, stxSignTransactionRequestMessageSchema, stxSignTransactionResultSchema, transferRunesMethodName, transferRunesParamsSchema, transferRunesRequestSchema, walletEventSchema, walletTypeSchema, walletTypes };
