// src/provider/types.ts
import * as v from "valibot";
var accountChangeEventName = "accountChange";
var accountChangeSchema = v.object({
  type: v.literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange";
var networkChangeSchema = v.object({
  type: v.literal(networkChangeEventName)
});
var disconnectEventName = "disconnect";
var disconnectSchema = v.object({
  type: v.literal(disconnectEventName)
});
var walletEventSchema = v.variant("type", [
  accountChangeSchema,
  networkChangeSchema,
  disconnectSchema
]);

// src/provider/index.ts
async function getProviderOrThrow(getProvider) {
  const provider = await getProvider?.() || window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (!provider) {
    throw new Error("No Bitcoin wallet installed");
  }
  return provider;
}
function getProviders() {
  if (!window.btc_providers)
    window.btc_providers = [];
  return window.btc_providers;
}
function getProviderById(providerId) {
  return providerId?.split(".").reduce((acc, part) => acc?.[part], window);
}
function isProviderInstalled(providerId) {
  return !!getProviderById(providerId);
}
function setDefaultProvider(providerId) {
  localStorage.setItem("sats-connect_defaultProvider", providerId);
}
function getDefaultProvider() {
  return localStorage.getItem("sats-connect_defaultProvider");
}
function removeDefaultProvider() {
  localStorage.removeItem("sats-connect_defaultProvider");
}
function getSupportedWallets() {
  const wallets = Object.values(DefaultAdaptersInfo).map((provider) => {
    {
      return {
        ...provider,
        isInstalled: isProviderInstalled(provider.id)
      };
    }
  });
  return wallets;
}

// src/types.ts
import * as v2 from "valibot";
var BitcoinNetworkType = /* @__PURE__ */ ((BitcoinNetworkType3) => {
  BitcoinNetworkType3["Mainnet"] = "Mainnet";
  BitcoinNetworkType3["Testnet"] = "Testnet";
  BitcoinNetworkType3["Signet"] = "Signet";
  return BitcoinNetworkType3;
})(BitcoinNetworkType || {});
var RpcIdSchema = v2.optional(v2.union([v2.string(), v2.number(), v2.null()]));
var rpcRequestMessageSchema = v2.object({
  jsonrpc: v2.literal("2.0"),
  method: v2.string(),
  params: v2.optional(
    v2.union([
      v2.array(v2.unknown()),
      v2.looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      v2.null()
    ])
  ),
  id: RpcIdSchema
});
var RpcErrorCode = /* @__PURE__ */ ((RpcErrorCode2) => {
  RpcErrorCode2[RpcErrorCode2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  RpcErrorCode2[RpcErrorCode2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  RpcErrorCode2[RpcErrorCode2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  RpcErrorCode2[RpcErrorCode2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  RpcErrorCode2[RpcErrorCode2["USER_REJECTION"] = -32e3] = "USER_REJECTION";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_SUPPORTED"] = -32001] = "METHOD_NOT_SUPPORTED";
  RpcErrorCode2[RpcErrorCode2["ACCESS_DENIED"] = -32002] = "ACCESS_DENIED";
  return RpcErrorCode2;
})(RpcErrorCode || {});
var rpcSuccessResponseMessageSchema = v2.object({
  jsonrpc: v2.literal("2.0"),
  result: v2.nonOptional(v2.unknown()),
  id: RpcIdSchema
});
var rpcErrorResponseMessageSchema = v2.object({
  jsonrpc: v2.literal("2.0"),
  error: v2.nonOptional(v2.unknown()),
  id: RpcIdSchema
});
var rpcResponseMessageSchema = v2.union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);

// src/request/index.ts
import * as v10 from "valibot";

// src/request/types/stxMethods.ts
import * as v4 from "valibot";

// src/addresses/index.ts
import { createUnsecuredToken } from "jsontokens";

// src/addresses/types.ts
import * as v3 from "valibot";
var AddressPurpose = /* @__PURE__ */ ((AddressPurpose2) => {
  AddressPurpose2["Ordinals"] = "ordinals";
  AddressPurpose2["Payment"] = "payment";
  AddressPurpose2["Stacks"] = "stacks";
  return AddressPurpose2;
})(AddressPurpose || {});
var AddressType = /* @__PURE__ */ ((AddressType3) => {
  AddressType3["p2pkh"] = "p2pkh";
  AddressType3["p2sh"] = "p2sh";
  AddressType3["p2wpkh"] = "p2wpkh";
  AddressType3["p2wsh"] = "p2wsh";
  AddressType3["p2tr"] = "p2tr";
  AddressType3["stacks"] = "stacks";
  return AddressType3;
})(AddressType || {});
var addressSchema = v3.object({
  address: v3.string(),
  publicKey: v3.string(),
  purpose: v3.enum(AddressPurpose),
  addressType: v3.enum(AddressType)
});

// src/addresses/index.ts
var getAddress = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { purposes } = options.payload;
  if (!purposes) {
    throw new Error("Address purposes are required");
  }
  try {
    const request2 = createUnsecuredToken(options.payload);
    const response = await provider.connect(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during address request", error);
    options.onCancel?.();
  }
};

// src/request/types/stxMethods.ts
var stxGetAddressesMethodName = "stx_getAddresses";
var stxGetAddressesParamsSchema = v4.nullish(
  v4.object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: v4.optional(v4.string())
  })
);
var stxGetAddressesResultSchema = v4.object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: v4.array(addressSchema)
});
var stxGetAddressesRequestMessageSchema = v4.object({
  ...rpcRequestMessageSchema.entries,
  ...v4.object({
    method: v4.literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: v4.string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction";
var stxSignTransactionParamsSchema = v4.object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: v4.string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: v4.optional(v4.string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: v4.optional(v4.boolean())
});
var stxSignTransactionResultSchema = v4.object({
  /**
   * The signed transaction as a hex-encoded string.
   */
  transaction: v4.string()
});
var stxSignTransactionRequestMessageSchema = v4.object({
  ...rpcRequestMessageSchema.entries,
  ...v4.object({
    method: v4.literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: v4.string()
  }).entries
});

// src/request/types/btcMethods.ts
import * as v6 from "valibot";

// src/request/types/common.ts
import * as v5 from "valibot";
var walletTypes = ["software", "ledger"];
var walletTypeSchema = v5.picklist(walletTypes);

// src/request/types/btcMethods.ts
var getInfoMethodName = "getInfo";
var getInfoParamsSchema = v6.nullish(v6.null());
var getInfoResultSchema = v6.object({
  /**
   * Version of the wallet.
   */
  version: v6.string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: v6.optional(v6.array(v6.string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: v6.array(v6.string())
});
var getInfoRequestMessageSchema = v6.object({
  ...rpcRequestMessageSchema.entries,
  ...v6.object({
    method: v6.literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: v6.string()
  }).entries
});
var getAddressesMethodName = "getAddresses";
var getAddressesParamsSchema = v6.object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: v6.array(v6.enum(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: v6.optional(v6.string())
});
var getAddressesResultSchema = v6.object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: v6.array(addressSchema)
});
var getAddressesRequestMessageSchema = v6.object({
  ...rpcRequestMessageSchema.entries,
  ...v6.object({
    method: v6.literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: v6.string()
  }).entries
});
var signMessageMethodName = "signMessage";
var MessageSigningProtocols = /* @__PURE__ */ ((MessageSigningProtocols2) => {
  MessageSigningProtocols2["ECDSA"] = "ECDSA";
  MessageSigningProtocols2["BIP322"] = "BIP322";
  return MessageSigningProtocols2;
})(MessageSigningProtocols || {});
var signMessageParamsSchema = v6.object({
  /**
   * The address used for signing.
   **/
  address: v6.string(),
  /**
   * The message to sign.
   **/
  message: v6.string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: v6.optional(v6.enum(MessageSigningProtocols))
});
var signMessageResultSchema = v6.object({
  /**
   * The signature of the message.
   */
  signature: v6.string(),
  /**
   * hash of the message.
   */
  messageHash: v6.string(),
  /**
   * The address used for signing.
   */
  address: v6.string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: v6.enum(MessageSigningProtocols)
});
var signMessageRequestMessageSchema = v6.object({
  ...rpcRequestMessageSchema.entries,
  ...v6.object({
    method: v6.literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: v6.string()
  }).entries
});
var getAccountsMethodName = "getAccounts";
var getAccountsParamsSchema = v6.object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: v6.array(v6.enum(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: v6.optional(v6.string())
});
var getAccountsResultSchema = v6.array(
  v6.object({
    ...addressSchema.entries,
    ...v6.object({
      walletType: walletTypeSchema
    }).entries
  })
);
var getAccountsRequestMessageSchema = v6.object({
  ...rpcRequestMessageSchema.entries,
  ...v6.object({
    method: v6.literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: v6.string()
  }).entries
});
var getBalanceMethodName = "getBalance";
var getBalanceParamsSchema = v6.nullish(v6.null());
var getBalanceResultSchema = v6.object({
  /**
   * The confirmed balance of the wallet in sats. Using a string due to chrome
   * messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  confirmed: v6.string(),
  /**
   * The unconfirmed balance of the wallet in sats. Using a string due to chrome
   * messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  unconfirmed: v6.string(),
  /**
   * The total balance (both confirmed and unconfrimed UTXOs) of the wallet in
   * sats. Using a string due to chrome messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  total: v6.string()
});
var getBalanceRequestMessageSchema = v6.object({
  ...rpcRequestMessageSchema.entries,
  ...v6.object({
    method: v6.literal(getBalanceMethodName),
    id: v6.string()
  }).entries
});

// src/request/types/walletMethods.ts
import * as v7 from "valibot";
var requestPermissionsMethodName = "wallet_requestPermissions";
var requestPermissionsParamsSchema = v7.undefined();
var requestPermissionsResultSchema = v7.literal(true);
var requestPermissionsRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: v7.string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions";
var renouncePermissionsParamsSchema = v7.undefined();
var renouncePermissionsResultSchema = v7.literal(true);
var renouncePermissionsRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: v7.string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType";
var getWalletTypeParamsSchema = v7.nullish(v7.null());
var getWalletTypeResultSchema = walletTypeSchema;
var getWalletTypeRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(getWalletTypeMethodName),
    id: v7.string()
  }).entries
});

// src/request/types/runesMethods.ts
import * as v8 from "valibot";
var getRunesBalanceMethodName = "runes_getBalance";
var getRunesBalanceParamsSchema = v8.nullish(v8.null());
var getRunesBalanceResultSchema = v8.object({
  balances: v8.array(
    v8.object({
      runeName: v8.string(),
      amount: v8.string(),
      divisibility: v8.number(),
      symbol: v8.string(),
      inscriptionId: v8.nullish(v8.string())
    })
  )
});
var getRunesBalanceRequestMessageSchema = v8.object({
  ...rpcRequestMessageSchema.entries,
  ...v8.object({
    method: v8.literal(getRunesBalanceMethodName),
    params: getRunesBalanceParamsSchema,
    id: v8.string()
  }).entries
});
var transferRunesMethodName = "runes_transfer";
var transferRunesParamsSchema = v8.object({
  recipients: v8.array(
    v8.object({
      runeName: v8.string(),
      amount: v8.string(),
      address: v8.string()
    })
  )
});
var transferRunesRequestSchema = v8.object({
  ...rpcRequestMessageSchema.entries,
  ...v8.object({
    method: v8.literal(transferRunesMethodName),
    params: transferRunesParamsSchema,
    id: v8.string()
  }).entries
});
var TransferRunesResultSchema = v8.object({
  txid: v8.string()
});

// src/request/types/ordinalsMethods.ts
import * as v9 from "valibot";
var getInscriptionsMethodName = "ord_getInscriptions";
var getInscriptionsParamsSchema = v9.object({
  offset: v9.number(),
  limit: v9.number()
});
var getInscriptionsResultSchema = v9.object({
  total: v9.number(),
  limit: v9.number(),
  offset: v9.number(),
  inscriptions: v9.array(
    v9.object({
      inscriptionId: v9.string(),
      inscriptionNumber: v9.string(),
      address: v9.string(),
      collectionName: v9.optional(v9.string()),
      postage: v9.string(),
      contentLength: v9.string(),
      contentType: v9.string(),
      timestamp: v9.number(),
      offset: v9.number(),
      genesisTransaction: v9.string(),
      output: v9.string()
    })
  )
});
var getInscriptionsSchema = v9.object({
  ...rpcRequestMessageSchema.entries,
  ...v9.object({
    method: v9.literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: v9.string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions";
var sendInscriptionsParamsSchema = v9.object({
  transfers: v9.array(
    v9.object({
      address: v9.string(),
      inscriptionId: v9.string()
    })
  )
});
var sendInscriptionsResultSchema = v9.object({
  txid: v9.string()
});
var sendInscriptionsSchema = v9.object({
  ...rpcRequestMessageSchema.entries,
  ...v9.object({
    method: v9.literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: v9.string()
  }).entries
});

// src/request/index.ts
var request = async (method, params, providerId) => {
  let provider = window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (providerId) {
    provider = await getProviderById(providerId);
  }
  if (!provider) {
    throw new Error("no wallet provider was found");
  }
  if (!method) {
    throw new Error("A wallet method is required");
  }
  const response = await provider.request(method, params);
  if (v10.is(rpcErrorResponseMessageSchema, response)) {
    return {
      status: "error",
      error: response.error
    };
  }
  if (v10.is(rpcSuccessResponseMessageSchema, response)) {
    return {
      status: "success",
      result: response.result
    };
  }
  return {
    status: "error",
    error: {
      code: -32603 /* INTERNAL_ERROR */,
      message: "Received unknown response from provider.",
      data: response
    }
  };
};
var addListener = (event, cb, providerId) => {
  let provider = window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (providerId) {
    provider = getProviderById(providerId);
  }
  if (!provider) {
    throw new Error("no wallet provider was found");
  }
  if (!provider.addListener) {
    console.error(
      `The wallet provider you are using does not support the addListener method. Please update your wallet provider.`
    );
    return () => {
    };
  }
  return provider.addListener(event, cb);
};

// src/runes/api.ts
import axios from "axios";
var urlNetworkSuffix = {
  ["Mainnet" /* Mainnet */]: "",
  ["Testnet" /* Testnet */]: "-testnet",
  ["Signet" /* Signet */]: "-signet"
};
var ORDINALS_API_BASE_URL = (network = "Mainnet" /* Mainnet */) => `https://ordinals${urlNetworkSuffix[network]}.xverse.app/v1`;
var RunesApi = class {
  client;
  constructor(network) {
    this.client = axios.create({
      baseURL: ORDINALS_API_BASE_URL(network)
    });
  }
  parseError = (error) => {
    return {
      code: error.response?.status,
      message: JSON.stringify(error.response?.data)
    };
  };
  estimateMintCost = async (mintParams) => {
    try {
      const response = await this.client.post("/runes/mint/estimate", {
        ...mintParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  estimateEtchCost = async (etchParams) => {
    try {
      const response = await this.client.post("/runes/etch/estimate", {
        ...etchParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createMintOrder = async (mintOrderParams) => {
    try {
      const response = await this.client.post("/runes/mint/orders", {
        ...mintOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createEtchOrder = async (etchOrderParams) => {
    try {
      const response = await this.client.post("/runes/etch/orders", {
        ...etchOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeMint = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/mint/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeEtch = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/etch/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  getOrder = async (orderId) => {
    try {
      const response = await this.client.get(`/orders/${orderId}`);
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  rbfOrder = async (rbfRequest) => {
    const { orderId, newFeeRate } = rbfRequest;
    try {
      const response = await this.client.post(`/orders/${orderId}/rbf-estimate`, {
        newFeeRate
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
};
var clients = {};
var getRunesApiClient = (network = "Mainnet" /* Mainnet */) => {
  if (!clients[network]) {
    clients[network] = new RunesApi(network);
  }
  return clients[network];
};

// src/adapters/satsConnectAdapter.ts
var SatsConnectAdapter = class {
  async mintRunes(params) {
    try {
      const walletInfo = await this.requestInternal("getInfo", null).catch(() => null);
      if (walletInfo && walletInfo.status === "success") {
        const isMintSupported = walletInfo.result.methods?.includes("runes_mint");
        if (isMintSupported) {
          const response = await this.requestInternal("runes_mint", params);
          if (response) {
            if (response.status === "success") {
              return response;
            }
            if (response.status === "error" && response.error.code !== -32601 /* METHOD_NOT_FOUND */) {
              return response;
            }
          }
        }
      }
      const mintRequest = {
        destinationAddress: params.destinationAddress,
        feeRate: params.feeRate,
        refundAddress: params.refundAddress,
        repeats: params.repeats,
        runeName: params.runeName,
        appServiceFee: params.appServiceFee,
        appServiceFeeAddress: params.appServiceFeeAddress
      };
      const orderResponse = await new RunesApi(params.network).createMintOrder(mintRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      await new RunesApi(params.network).executeMint(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid,
          fundingAddress: orderResponse.data.fundAddress
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async etchRunes(params) {
    const etchRequest = {
      destinationAddress: params.destinationAddress,
      refundAddress: params.refundAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    try {
      const walletInfo = await this.requestInternal("getInfo", null).catch(() => null);
      if (walletInfo && walletInfo.status === "success") {
        const isEtchSupported = walletInfo.result.methods?.includes("runes_etch");
        if (isEtchSupported) {
          const response = await this.requestInternal("runes_etch", params);
          if (response) {
            if (response.status === "success") {
              return response;
            }
            if (response.status === "error" && response.error.code !== -32601 /* METHOD_NOT_FOUND */) {
              return response;
            }
          }
        }
      }
      const orderResponse = await new RunesApi(params.network).createEtchOrder(etchRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      await new RunesApi(params.network).executeEtch(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid,
          fundingAddress: orderResponse.data.fundAddress
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async estimateMint(params) {
    const estimateMintRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      repeats: params.repeats,
      runeName: params.runeName,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(
      params.network
    ).estimateMintCost(estimateMintRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async estimateEtch(params) {
    const estimateEtchRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(params.network).estimateEtchCost(estimateEtchRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async getOrder(params) {
    const response = await getRunesApiClient(params.network).getOrder(params.id);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 || response.error.code === 404 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async estimateRbfOrder(params) {
    const rbfOrderRequest = {
      newFeeRate: params.newFeeRate,
      orderId: params.orderId
    };
    const response = await getRunesApiClient(params.network).rbfOrder(rbfOrderRequest);
    if (response.data) {
      return {
        status: "success",
        result: {
          fundingAddress: response.data.fundingAddress,
          rbfCost: response.data.rbfCost
        }
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 || response.error.code === 404 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async rbfOrder(params) {
    try {
      const rbfOrderRequest = {
        newFeeRate: params.newFeeRate,
        orderId: params.orderId
      };
      const orderResponse = await getRunesApiClient(params.network).rbfOrder(rbfOrderRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 || orderResponse.error.code === 404 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundingAddress,
            amount: orderResponse.data.rbfCost
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      return {
        status: "success",
        result: {
          fundingAddress: orderResponse.data.fundingAddress,
          orderId: rbfOrderRequest.orderId,
          fundRBFTransactionId: paymentResponse.result.txid
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async request(method, params) {
    switch (method) {
      case "runes_mint":
        return this.mintRunes(params);
      case "runes_etch":
        return this.etchRunes(params);
      case "runes_estimateMint":
        return this.estimateMint(params);
      case "runes_estimateEtch":
        return this.estimateEtch(params);
      case "runes_getOrder": {
        return this.getOrder(params);
      }
      case "runes_estimateRbfOrder": {
        return this.estimateRbfOrder(params);
      }
      case "runes_rbfOrder": {
        return this.rbfOrder(params);
      }
      default:
        return this.requestInternal(method, params);
    }
  }
};

// src/adapters/xverse.ts
var XverseAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.xverse.id;
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
  addListener = (event, cb) => {
    return addListener(
      event,
      // The types of the `addListener` function being called here are not
      // entirely accurate.
      cb,
      this.id
    );
  };
};

// src/adapters/unisat.ts
import { AddressType as AddressType2, getAddressInfo } from "bitcoin-address-validation";
import { Buffer } from "buffer";
function convertSignInputsToInputType(signInputs) {
  let result = [];
  for (let address in signInputs) {
    let indexes = signInputs[address];
    for (let index of indexes) {
      result.push({
        index,
        address
      });
    }
  }
  return result;
}
var UnisatAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.unisat.id;
  async getAccounts(params) {
    const { purposes } = params;
    if (purposes.includes("stacks" /* Stacks */)) {
      throw new Error("Only bitcoin addresses are supported");
    }
    const accounts = await window.unisat.requestAccounts();
    const publicKey = await window.unisat.getPublicKey();
    const address = accounts[0];
    const addressType = getAddressInfo(accounts[0]).type;
    const pk = addressType === AddressType2.p2tr ? publicKey.slice(2) : publicKey;
    const paymentAddress = {
      address,
      publicKey: pk,
      addressType,
      purpose: "payment" /* Payment */
    };
    const ordinalsAddress = {
      address,
      publicKey: pk,
      addressType,
      purpose: "ordinals" /* Ordinals */
    };
    const response = [];
    if (purposes.includes("payment" /* Payment */)) {
      response.push({ ...paymentAddress, walletType: "software" });
    }
    if (purposes.includes("ordinals" /* Ordinals */)) {
      response.push({ ...ordinalsAddress, walletType: "software" });
    }
    return response;
  }
  async signMessage(params) {
    const { message, address } = params;
    const addressType = getAddressInfo(address).type;
    const Bip322supportedTypes = [AddressType2.p2wpkh, AddressType2.p2tr];
    if (Bip322supportedTypes.includes(addressType)) {
      const response2 = await window.unisat.signMessage(message, "bip322-simple");
      return {
        address,
        messageHash: "",
        signature: response2,
        protocol: "BIP322" /* BIP322 */
      };
    }
    const response = await window.unisat.signMessage(message, "ecdsa");
    return {
      address,
      messageHash: "",
      signature: response,
      protocol: "ECDSA" /* ECDSA */
    };
  }
  async sendTransfer(params) {
    const { recipients } = params;
    if (recipients.length > 1) {
      throw new Error("Only one recipient is supported by this wallet provider");
    }
    const txid = await window.unisat.sendBitcoin(recipients[0].address, recipients[0].amount);
    return {
      txid
    };
  }
  async signPsbt(params) {
    const { psbt, signInputs, broadcast } = params;
    const psbtHex = Buffer.from(psbt, "base64").toString("hex");
    const signedPsbt = await window.unisat.signPsbt(psbtHex, {
      autoFinalized: broadcast,
      toSignInputs: convertSignInputsToInputType(signInputs)
    });
    if (broadcast) {
      const txid = await window.unisat.pushPsbt(psbtHex);
      return {
        psbt: signedPsbt,
        txid
      };
    }
    return {
      psbt: psbtHex
    };
  }
  requestInternal = async (method, params) => {
    try {
      switch (method) {
        case "getAccounts": {
          const response = await this.getAccounts(
            params
          );
          return {
            status: "success",
            result: response
          };
        }
        case "sendTransfer": {
          const response = await this.sendTransfer(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signMessage": {
          const response = await this.signMessage(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signPsbt": {
          const response = await this.signPsbt(params);
          return {
            status: "success",
            result: response
          };
        }
        default: {
          const error = {
            code: -32001 /* METHOD_NOT_SUPPORTED */,
            message: "Method not supported by the selected wallet"
          };
          console.error("Error calling the method", error);
          return {
            status: "error",
            error
          };
        }
      }
    } catch (error) {
      console.error("Error calling the method", error);
      return {
        status: "error",
        error: {
          code: error.code === 4001 ? -32e3 /* USER_REJECTION */ : -32603 /* INTERNAL_ERROR */,
          message: error.message ? error.message : "Wallet method call error",
          data: error
        }
      };
    }
  };
  addListener = (eventName, cb) => {
    switch (eventName) {
      case "accountChange": {
        const handler = () => {
          cb({ type: "accountChange" });
        };
        window.unisat.on("accountsChanged", handler);
        return () => {
          window.unisat.removeListener("accountsChanged", handler);
        };
      }
      case "networkChange": {
        const handler = () => {
          cb({ type: "networkChange" });
        };
        window.unisat.on("networkChanged", handler);
        return () => {
          window.unisat.removeListener("networkChanged", handler);
        };
      }
      default: {
        console.error("Event not supported by the selected wallet");
        return () => {
        };
      }
    }
  };
};

// src/adapters/BaseAdapter.ts
var BaseAdapter = class extends SatsConnectAdapter {
  id = "";
  constructor(providerId) {
    super();
    this.id = providerId;
  }
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
  addListener = (..._args) => {
    throw new Error("Method not supported for `BaseAdapter`.");
  };
};

// src/adapters/index.ts
var DefaultAdaptersInfo = {
  xverse: {
    id: "XverseProviders.BitcoinProvider",
    name: "Xverse",
    webUrl: "https://www.xverse.app/",
    googlePlayStoreUrl: "https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse",
    iOSAppStoreUrl: "https://apps.apple.com/app/xverse-bitcoin-web3-wallet/id1552272513",
    chromeWebStoreUrl: "https://chromewebstore.google.com/detail/xverse-wallet/idnnbdplmphpflfnlkomgpfbpcgelopg",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgdmlld0JveD0iMCAwIDEwMiAxMDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGlkPSJJY29uX0FydCAoRWRpdCBNZSkiPgo8cmVjdCB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgZmlsbD0iIzE4MTgxOCIvPgo8ZyBpZD0iTG9nby9FbWJsZW0iIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMF8xMjIzKSI+CjxwYXRoIGlkPSJWZWN0b3IiIGQ9Ik03NC42NTQyIDczLjg4ODNWNjUuMjMxMkM3NC42NTQyIDY0Ljg4OCA3NC41MTc3IDY0LjU2MDYgNzQuMjc0NSA2NC4zMTc0TDM3LjQzOTcgMjcuNDgyNUMzNy4xOTY1IDI3LjIzOTIgMzYuODY5MSAyNy4xMDI4IDM2LjUyNTggMjcuMTAyOEgyNy44NjlDMjcuNDQxNiAyNy4xMDI4IDI3LjA5MzggMjcuNDUwNiAyNy4wOTM4IDI3Ljg3OFYzNS45MjExQzI3LjA5MzggMzYuMjY0NCAyNy4yMzAyIDM2LjU5MTcgMjcuNDczNCAzNi44MzVMNDAuNjk1MiA1MC4wNTY3QzQwLjk5NzUgNTAuMzU5MSA0MC45OTc1IDUwLjg1MDEgNDAuNjk1MiA1MS4xNTI0TDI3LjMyMTEgNjQuNTI2NUMyNy4xNzU2IDY0LjY3MiAyNy4wOTM4IDY0Ljg2OTggMjcuMDkzOCA2NS4wNzQ0VjczLjg4ODNDMjcuMDkzOCA3NC4zMTUzIDI3LjQ0MTYgNzQuNjYzNSAyNy44NjkgNzQuNjYzNUg0Mi4zMzQyQzQyLjc2MTYgNzQuNjYzNSA0My4xMDk0IDc0LjMxNTMgNDMuMTA5NCA3My44ODgzVjY4LjY5NThDNDMuMTA5NCA2OC40OTEyIDQzLjE5MTIgNjguMjkzNSA0My4zMzY4IDY4LjE0NzlMNTAuNTExNCA2MC45NzMzQzUwLjgxMzggNjAuNjcwOSA1MS4zMDQ4IDYwLjY3MDkgNTEuNjA3MiA2MC45NzMzTDY0LjkxOTggNzQuMjg2MUM2NS4xNjMxIDc0LjUyOTMgNjUuNDkwNCA3NC42NjU4IDY1LjgzMzcgNzQuNjY1OEg3My44NzY3Qzc0LjMwNDIgNzQuNjY1OCA3NC42NTE5IDc0LjMxNzYgNzQuNjUxOSA3My44OTA2TDc0LjY1NDIgNzMuODg4M1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGlkPSJWZWN0b3JfMiIgZD0iTTU1LjM1OCAzOC41NjcySDYyLjYwMzFDNjMuMDMyOCAzOC41NjcyIDYzLjM4MjkgMzguOTE3MyA2My4zODI5IDM5LjM0NjlWNDYuNTkyMUM2My4zODI5IDQ3LjI4NzcgNjQuMjI0IDQ3LjYzNTUgNjQuNzE1MSA0Ny4xNDIyTDc0LjY1NDEgMzcuMTg3M0M3NC43OTk0IDM3LjA0MTggNzQuODgxNiAzNi44NDQgNzQuODgxNiAzNi42MzcxVjI3LjkxODlDNzQuODgxNiAyNy40ODkyIDc0LjUzMzQgMjcuMTM5MSA3NC4xMDE3IDI3LjEzOTFMNjUuMjUzOCAyNy4xMjc3QzY1LjA0NyAyNy4xMjc3IDY0Ljg0OTIgMjcuMjA5NiA2NC43MDE0IDI3LjM1NTFMNTQuODA1NiAzNy4yMzVDNTQuMzE0NSAzNy43MjYgNTQuNjYyMyAzOC41NjcyIDU1LjM1NTcgMzguNTY3Mkg1NS4zNThaIiBmaWxsPSIjRUU3QTMwIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMF8xMjIzIj4KPHJlY3Qgd2lkdGg9IjQ3LjgxMjUiIGhlaWdodD0iNDcuODEyNSIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3LjA5MzggMjcuMDkzOCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K"
  },
  unisat: {
    id: "unisat",
    name: "Unisat",
    webUrl: "https://unisat.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTAwNTBfNDE3MSkiPgo8cGF0aCBkPSJNMTEzLjY2IDI5LjI4OTdMMTQzLjk3IDU5LjMwOTdDMTQ2LjU1IDYxLjg1OTcgMTQ3LjgyIDY0LjQzOTcgMTQ3Ljc4IDY3LjAzOTdDMTQ3Ljc0IDY5LjYzOTcgMTQ2LjYzIDcyLjAwOTcgMTQ0LjQ2IDc0LjE1OTdDMTQyLjE5IDc2LjQwOTcgMTM5Ljc0IDc3LjU0OTcgMTM3LjEyIDc3LjU5OTdDMTM0LjUgNzcuNjM5NyAxMzEuOSA3Ni4zNzk3IDEyOS4zMiA3My44Mjk3TDk4LjMxOTkgNDMuMTI5N0M5NC43OTk5IDM5LjYzOTcgOTEuMzk5OSAzNy4xNjk3IDg4LjEyOTkgMzUuNzE5N0M4NC44NTk5IDM0LjI2OTcgODEuNDE5OSAzNC4wMzk3IDc3LjgxOTkgMzUuMDM5N0M3NC4yMDk5IDM2LjAyOTcgNzAuMzM5OSAzOC41Nzk3IDY2LjE4OTkgNDIuNjc5N0M2MC40Njk5IDQ4LjM0OTcgNTcuNzM5OSA1My42Njk3IDU4LjAxOTkgNTguNjM5N0M1OC4yOTk5IDYzLjYwOTcgNjEuMTM5OSA2OC43Njk3IDY2LjUyOTkgNzQuMDk5N0w5Ny43Nzk5IDEwNS4wNkMxMDAuMzkgMTA3LjY0IDEwMS42NyAxMTAuMjIgMTAxLjYzIDExMi43OEMxMDEuNTkgMTE1LjM1IDEwMC40NyAxMTcuNzIgOTguMjU5OSAxMTkuOTFDOTYuMDU5OSAxMjIuMDkgOTMuNjI5OSAxMjMuMjMgOTAuOTg5OSAxMjMuMzJDODguMzQ5OSAxMjMuNDEgODUuNzE5OSAxMjIuMTYgODMuMTE5OSAxMTkuNThMNTIuODA5OSA4OS41NTk3QzQ3Ljg3OTkgODQuNjc5NyA0NC4zMTk5IDgwLjA1OTcgNDIuMTI5OSA3NS42OTk3QzM5LjkzOTkgNzEuMzM5NyAzOS4xMTk5IDY2LjQwOTcgMzkuNjg5OSA2MC45MDk3QzQwLjE5OTkgNTYuMTk5NyA0MS43MDk5IDUxLjYzOTcgNDQuMjI5OSA0Ny4yMTk3QzQ2LjczOTkgNDIuNzk5NyA1MC4zMzk5IDM4LjI3OTcgNTUuMDA5OSAzMy42NDk3QzYwLjU2OTkgMjguMTM5NyA2NS44Nzk5IDIzLjkxOTcgNzAuOTM5OSAyMC45Nzk3Qzc1Ljk4OTkgMTguMDM5NyA4MC44Nzk5IDE2LjQwOTcgODUuNTk5OSAxNi4wNjk3QzkwLjMyOTkgMTUuNzI5NyA5NC45ODk5IDE2LjY2OTcgOTkuNTk5OSAxOC44ODk3QzEwNC4yMSAyMS4xMDk3IDEwOC44OSAyNC41Njk3IDExMy42NSAyOS4yODk3SDExMy42NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxKSIvPgo8cGF0aCBkPSJNNjYuMTA5OSAxNTAuNDJMMzUuODA5OSAxMjAuNEMzMy4yMjk5IDExNy44NCAzMS45NTk5IDExNS4yNyAzMS45OTk5IDExMi42N0MzMi4wMzk5IDExMC4wNyAzMy4xNDk5IDEwNy43IDM1LjMxOTkgMTA1LjU1QzM3LjU4OTkgMTAzLjMgNDAuMDM5OSAxMDIuMTYgNDIuNjU5OSAxMDIuMTFDNDUuMjc5OSAxMDIuMDcgNDcuODc5OSAxMDMuMzIgNTAuNDU5OSAxMDUuODhMODEuNDQ5OSAxMzYuNThDODQuOTc5OSAxNDAuMDcgODguMzY5OSAxNDIuNTQgOTEuNjM5OSAxNDMuOTlDOTQuOTA5OSAxNDUuNDQgOTguMzQ5OSAxNDUuNjYgMTAxLjk2IDE0NC42N0MxMDUuNTcgMTQzLjY4IDEwOS40NCAxNDEuMTMgMTEzLjU5IDEzNy4wMkMxMTkuMzEgMTMxLjM1IDEyMi4wNCAxMjYuMDMgMTIxLjc2IDEyMS4wNkMxMjEuNDggMTE2LjA5IDExOC42NCAxMTAuOTMgMTEzLjI1IDEwNS41OUw5Ni41OTk5IDg5LjI0MDFDOTMuOTg5OSA4Ni42NjAxIDkyLjcwOTkgODQuMDgwMSA5Mi43NDk5IDgxLjUyMDFDOTIuNzg5OSA3OC45NTAxIDkzLjkwOTkgNzYuNTgwMSA5Ni4xMTk5IDc0LjM5MDFDOTguMzE5OSA3Mi4yMTAxIDEwMC43NSA3MS4wNzAxIDEwMy4zOSA3MC45ODAxQzEwNi4wMyA3MC44OTAxIDEwOC42NiA3Mi4xNDAxIDExMS4yNiA3NC43MjAxTDEyNi45NiA5MC4xMzAxQzEzMS44OSA5NS4wMTAxIDEzNS40NSA5OS42MzAxIDEzNy42NCAxMDMuOTlDMTM5LjgzIDEwOC4zNSAxNDAuNjUgMTEzLjI4IDE0MC4wOCAxMTguNzhDMTM5LjU3IDEyMy40OSAxMzguMDYgMTI4LjA1IDEzNS41NCAxMzIuNDdDMTMzLjAzIDEzNi44OSAxMjkuNDMgMTQxLjQxIDEyNC43NiAxNDYuMDRDMTE5LjIgMTUxLjU1IDExMy44OSAxNTUuNzcgMTA4LjgzIDE1OC43MUMxMDMuNzcgMTYxLjY1IDk4Ljg3OTkgMTYzLjI5IDk0LjE0OTkgMTYzLjYzQzg5LjQxOTkgMTYzLjk3IDg0Ljc1OTkgMTYzLjAzIDgwLjE0OTkgMTYwLjgxQzc1LjUzOTkgMTU4LjU5IDcwLjg1OTkgMTU1LjEzIDY2LjA5OTkgMTUwLjQxTDY2LjEwOTkgMTUwLjQyWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzEwMDUwXzQxNzEpIi8+CjxwYXRoIGQ9Ik04NS4wMDk5IDcyLjk1OTJDOTEuMTU2OCA3Mi45NTkyIDk2LjEzOTkgNjcuOTc2MSA5Ni4xMzk5IDYxLjgyOTJDOTYuMTM5OSA1NS42ODIzIDkxLjE1NjggNTAuNjk5MiA4NS4wMDk5IDUwLjY5OTJDNzguODYzIDUwLjY5OTIgNzMuODc5OSA1NS42ODIzIDczLjg3OTkgNjEuODI5MkM3My44Nzk5IDY3Ljk3NjEgNzguODYzIDcyLjk1OTIgODUuMDA5OSA3Mi45NTkyWiIgZmlsbD0idXJsKCNwYWludDJfcmFkaWFsXzEwMDUwXzQxNzEpIi8+CjwvZz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iMTM4Ljk4NSIgeTE9IjQ2Ljc3OTUiIHgyPSI0NS4wNTI5IiB5Mj0iODguNTIzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMjAxQzFCIi8+CjxzdG9wIG9mZnNldD0iMC4zNiIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRCODUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iNDMuMzgxMiIgeTE9IjEzNC4xNjciIHgyPSIxNTIuMjMxIiB5Mj0iMTAxLjc3MSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMUYxRDFDIi8+CjxzdG9wIG9mZnNldD0iMC4zNyIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRGQjUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQyX3JhZGlhbF8xMDA1MF80MTcxIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDg1LjAwOTkgNjEuODM5Mikgc2NhbGUoMTEuMTMpIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y0Qjg1MiIvPgo8c3RvcCBvZmZzZXQ9IjAuMzMiIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0IiBzdG9wLWNvbG9yPSIjNzczOTBEIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzIxMUMxRCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEwMDUwXzQxNzEiPgo8cmVjdCB3aWR0aD0iMTE1Ljc3IiBoZWlnaHQ9IjE0Ny43IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzIgMTYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
  }
};
var defaultAdapters = {
  [DefaultAdaptersInfo.xverse.id]: XverseAdapter,
  [DefaultAdaptersInfo.unisat.id]: UnisatAdapter
};

// src/capabilities/index.ts
import { createUnsecuredToken as createUnsecuredToken2 } from "jsontokens";
var extractOrValidateCapabilities = (provider, reportedCapabilities) => {
  const validateCapability = (capability) => {
    if (!provider[capability]) {
      return false;
    }
    if (reportedCapabilities && !reportedCapabilities.has(capability)) {
      return false;
    }
    return true;
  };
  const capabilityMap = {
    request: validateCapability("request"),
    connect: validateCapability("connect"),
    signMessage: validateCapability("signMessage"),
    signTransaction: validateCapability("signTransaction"),
    sendBtcTransaction: validateCapability("sendBtcTransaction"),
    createInscription: validateCapability("createInscription"),
    createRepeatInscriptions: validateCapability("createRepeatInscriptions"),
    signMultipleTransactions: validateCapability("signMultipleTransactions"),
    addListener: validateCapability("addListener")
  };
  return Object.entries(capabilityMap).reduce((acc, [capability, value]) => {
    if (value)
      return [...acc, capability];
    return acc;
  }, []);
};
var getCapabilities = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const request2 = createUnsecuredToken2(options.payload);
  if (provider.getCapabilities) {
    try {
      const response = await provider.getCapabilities(request2);
      options.onFinish?.(extractOrValidateCapabilities(provider, new Set(response)));
    } catch (error) {
      console.error("[Connect] Error during capabilities request", error);
    }
  }
  try {
    const inferredCapabilities = extractOrValidateCapabilities(provider);
    options.onFinish?.(inferredCapabilities);
  } catch (error) {
    console.error("[Connect] Error during capabilities request", error);
    options.onCancel?.();
  }
};

// src/inscriptions/createInscription.ts
import { createUnsecuredToken as createUnsecuredToken3 } from "jsontokens";

// src/inscriptions/utils.ts
var MAX_CONTENT_LENGTH_MAINNET = 4e5;
var MAX_CONTENT_LENGTH_TESTNET = 6e4;
var validateInscriptionPayload = (payload) => {
  const { contentType, content, payloadType, network, appFeeAddress, appFee } = payload;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(contentType)) {
    throw new Error("Invalid content type detected");
  }
  if (!content || content.length === 0) {
    throw new Error("Empty content not allowed");
  }
  if (!payloadType || payloadType !== "BASE_64" && payloadType !== "PLAIN_TEXT") {
    throw new Error("Empty invalid payloadType specified");
  }
  if (content.length > (network.type === "Mainnet" ? MAX_CONTENT_LENGTH_MAINNET : MAX_CONTENT_LENGTH_TESTNET)) {
    throw new Error("Content too large");
  }
  if ((appFeeAddress?.length ?? 0) > 0 && (appFee ?? 0) <= 0) {
    throw new Error("Invalid combination of app fee address and fee provided");
  }
};

// src/inscriptions/createInscription.ts
var createInscription = async (options) => {
  const { getProvider } = options;
  const provider = await getProviderOrThrow(getProvider);
  validateInscriptionPayload(options.payload);
  try {
    const request2 = createUnsecuredToken3(options.payload);
    const response = await provider.createInscription(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during create inscription", error);
    options.onCancel?.();
  }
};

// src/inscriptions/createRepeatInscriptions.ts
import { createUnsecuredToken as createUnsecuredToken4 } from "jsontokens";
var createRepeatInscriptions = async (options) => {
  const { getProvider } = options;
  const provider = await getProviderOrThrow(getProvider);
  validateInscriptionPayload(options.payload);
  try {
    const request2 = createUnsecuredToken4(options.payload);
    const response = await provider.createRepeatInscriptions(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during create repeat inscriptions", error);
    options.onCancel?.();
  }
};

// src/messages/index.ts
import { createUnsecuredToken as createUnsecuredToken5 } from "jsontokens";
var signMessage = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { address, message } = options.payload;
  if (!address) {
    throw new Error("An address is required to sign a message");
  }
  if (!message) {
    throw new Error("A message to be signed is required");
  }
  try {
    const request2 = createUnsecuredToken5(options.payload);
    const response = await provider.signMessage(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign message request", error);
    options.onCancel?.();
  }
};

// src/transactions/sendBtcTransaction.ts
import { createUnsecuredToken as createUnsecuredToken6 } from "jsontokens";
var serializer = (recipient) => {
  return recipient.map((value) => {
    const { address, amountSats } = value;
    return {
      address,
      amountSats: amountSats.toString()
    };
  });
};
var sendBtcTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { recipients, senderAddress, network, message } = options.payload;
  if (!recipients || recipients.length === 0) {
    throw new Error("At least one recipient is required");
  }
  if (recipients.some(
    (item) => typeof item.address !== "string" || typeof item.amountSats !== "bigint"
  )) {
    throw new Error("Incorrect recipient format");
  }
  if (!senderAddress) {
    throw new Error("The sender address is required");
  }
  try {
    const serializedRecipients = serializer(recipients);
    const serializedPayload = {
      network,
      senderAddress,
      message,
      recipients: serializedRecipients
    };
    const request2 = createUnsecuredToken6(serializedPayload);
    const response = await provider.sendBtcTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during send BTC transaction request", error);
    options.onCancel?.();
  }
};

// src/transactions/signTransaction.ts
import { createUnsecuredToken as createUnsecuredToken7 } from "jsontokens";
var signTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbtBase64, inputsToSign } = options.payload;
  if (!psbtBase64) {
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  }
  if (!inputsToSign) {
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  }
  try {
    const request2 = createUnsecuredToken7(options.payload);
    const response = await provider.signTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign transaction request", error);
    options.onCancel?.();
  }
};

// src/transactions/signMultipleTransactions.ts
import { createUnsecuredToken as createUnsecuredToken8 } from "jsontokens";
var signMultipleTransactions = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbts } = options.payload;
  if (!psbts || !psbts.length) {
    throw new Error("psbts array is required");
  }
  if (psbts.length > 100) {
    throw new Error("psbts array must contain less than 100 psbts");
  }
  try {
    const request2 = createUnsecuredToken8(options.payload);
    const response = await provider.signMultipleTransactions(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign Multiple transactions request", error);
    options.onCancel?.();
  }
};
export {
  AddressPurpose,
  AddressType,
  BaseAdapter,
  BitcoinNetworkType,
  DefaultAdaptersInfo,
  MessageSigningProtocols,
  RpcErrorCode,
  RpcIdSchema,
  SatsConnectAdapter,
  TransferRunesResultSchema,
  accountChangeEventName,
  accountChangeSchema,
  addListener,
  addressSchema,
  createInscription,
  createRepeatInscriptions,
  defaultAdapters,
  disconnectEventName,
  disconnectSchema,
  getAccountsMethodName,
  getAccountsParamsSchema,
  getAccountsRequestMessageSchema,
  getAccountsResultSchema,
  getAddress,
  getAddressesMethodName,
  getAddressesParamsSchema,
  getAddressesRequestMessageSchema,
  getAddressesResultSchema,
  getBalanceMethodName,
  getBalanceParamsSchema,
  getBalanceRequestMessageSchema,
  getBalanceResultSchema,
  getCapabilities,
  getDefaultProvider,
  getInfoMethodName,
  getInfoParamsSchema,
  getInfoRequestMessageSchema,
  getInfoResultSchema,
  getInscriptionsMethodName,
  getInscriptionsParamsSchema,
  getInscriptionsResultSchema,
  getInscriptionsSchema,
  getProviderById,
  getProviderOrThrow,
  getProviders,
  getRunesBalanceMethodName,
  getRunesBalanceParamsSchema,
  getRunesBalanceRequestMessageSchema,
  getRunesBalanceResultSchema,
  getSupportedWallets,
  getWalletTypeMethodName,
  getWalletTypeParamsSchema,
  getWalletTypeRequestMessageSchema,
  getWalletTypeResultSchema,
  isProviderInstalled,
  networkChangeEventName,
  networkChangeSchema,
  removeDefaultProvider,
  renouncePermissionsMethodName,
  renouncePermissionsParamsSchema,
  renouncePermissionsRequestMessageSchema,
  renouncePermissionsResultSchema,
  request,
  requestPermissionsMethodName,
  requestPermissionsParamsSchema,
  requestPermissionsRequestMessageSchema,
  requestPermissionsResultSchema,
  rpcErrorResponseMessageSchema,
  rpcRequestMessageSchema,
  rpcResponseMessageSchema,
  rpcSuccessResponseMessageSchema,
  sendBtcTransaction,
  sendInscriptionsMethodName,
  sendInscriptionsParamsSchema,
  sendInscriptionsResultSchema,
  sendInscriptionsSchema,
  setDefaultProvider,
  signMessage,
  signMessageMethodName,
  signMessageParamsSchema,
  signMessageRequestMessageSchema,
  signMessageResultSchema,
  signMultipleTransactions,
  signTransaction,
  stxGetAddressesMethodName,
  stxGetAddressesParamsSchema,
  stxGetAddressesRequestMessageSchema,
  stxGetAddressesResultSchema,
  stxSignTransactionMethodName,
  stxSignTransactionParamsSchema,
  stxSignTransactionRequestMessageSchema,
  stxSignTransactionResultSchema,
  transferRunesMethodName,
  transferRunesParamsSchema,
  transferRunesRequestSchema,
  walletEventSchema,
  walletTypeSchema,
  walletTypes
};
